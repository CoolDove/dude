package dshader

import "core:strings"
import "core:hash"
import "core:log"

import gl "vendor:OpenGL"

@(private="file")
HASH_SEED :u32: 0xddaaef

@(private="file")
MAX_UNIFORM_LOCATIONS :i32= -1

get_uniform_location :: proc(name: string) -> u32 {
    if MAX_UNIFORM_LOCATIONS == -1 do gl.GetIntegerv(gl.MAX_UNIFORM_LOCATIONS, &MAX_UNIFORM_LOCATIONS)
    data :[]byte= raw_data(name)[:len(name)]
    return hash.sdbm(data, HASH_SEED) % cast(u32) MAX_UNIFORM_LOCATIONS
}

@(private="file")
shader_libs : map[string]string

load_shader :: proc(source : string) {
}

load_shader_lib :: proc(source : string) {
    first_line_end := strings.index_rune(source, '\n')
}

@(private="file")
preprocess_shader :: proc(source : string, allocator := context.allocator) -> string {
    context.allocator = allocator
    sb : strings.Builder
    defer strings.builder_destroy(&sb)
    strings.builder_init(&sb)
    return strings.to_string(sb)
}

example_dshader_lib_simple : string : `
#package simple

float add(float x, float y) {
    return x + y;
}

`

example_dshader_lib_lighting : string : `
#package lighting

vec3 diffuse(float x, float y) {
    return x + y;
}

`

// NOTE(Dove): Still in design...
example_dshader_source : string : `
// Every *DShader Instruction (DSI)* line begins with a # character.
// A DSI is made up by #, name, the argument. The argument is a string or a "{}" block.
// And the argument will be processed by each instruction itself.

// Public region, layout and uniforms should be declared here.
#layout {
    vec3 position
    vec4 color
    vec3 normal
    vec2 uv
}

// Normal public code, you can place these things everywhere in the public region.
// They will be put into both vertex and fragment shaders without any modification.
struct LightingData {
    vec3 direction;
    vec4 color;
}

/* uniform block
Variables in this block will be placed into both vertex and fragment shader as uniforms.
The uniform location is generated by hashing the variable name.
*/ 
#uniform {
    mat4 matrix_view_projection;
    mat4 matrix_model;
    vec3 light_direction;
    vec4 light_color; // xyz: color, z: nor using

    LightData main_light;

    vec4 material_color;
}

#v2f {
    vec2 _uv; // will be pass into fragment shader from vertex shader.
    vec3 _normal;
    vec4 _color;
    mat4 _mat_local_to_world_direction;
}

#vertex_shader {
    void main() {
        _mat_local_to_world_direction = transpose(inverse(matrix_model));
        // vec4 wpos = matrix_model * vec4(position.x, position.y, position.z, 1);
        vec4 wpos = matrix_model * @(position.zxy, 1)
        gl_Position = matrix_view_projection * wpos;
    	_uv = uv;
        _color = color;
        _normal = normal;// not correct
    }
}

#include simple

/* @ vec
@(normal.xyz, 1)      =>    vec4(normal.x, normal.y, normal.z, 1)
@(normal.zy, 1, 0)    =>    vec4(normal.z, normal.y, 1, 0)
@(1, normal.x, 1)     =>    vec3(1, normal.x, 1)
*/

#fragment_shader {
    void main() {
        vec4 c = texture(main_texture, _uv);

        // FragColor = c * _color + vec4(_normal.x, _normal.y, _normal.z, 0) * 0.01;
        vec4 normal_vec4 = @(_normal.xyz, 1);
        normal_vec4 = _mat_local_to_world_direction * normal_vec4;
        // vec3 world_normal = vec3(normal_vec4.x, normal_vec4.y, normal_vec4.z);
        vec3 world_normal = @(normal_vec4.xyz);

        float n_dot_l = dot(normalize(world_normal), light_direction);
        n_dot_l = n_dot_l * 2 + 1;

        FragColor = c * _color * n_dot_l * light_color;
        FragColor.a = 1.0;

        // FragColor = vec4(n_dot_l, n_dot_l, n_dot_l, 1);
    }
}

`